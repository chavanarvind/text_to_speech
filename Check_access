def match_by_reference_table(erp: pd.DataFrame,  
                             tru: pd.DataFrame,  
                             reference_table: pd.DataFrame,  
                             last_match_round: int,  
                             round_name: str,  
                             bundles):  
    '''  
    A reference table contains two types of mappings, Part ID - RM Spec and their respective text descriptions.  
    This method attempts to match records using the two types of mappings.  
    '''  
    match_round_name = f'{last_match_round + 1}: {round_name}'  
    print(f'MATCH ROUND {match_round_name}')  
    start = time.time()  
    # First create matches per idx  
    df_erp_with_additional_id = erp[ERP_MATCH_COLS].merge(  
        reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),  
        on=ERP_PART_ID,  
        how='inner'  
    )  
    matched_per_id = df_erp_with_additional_id.merge(  
        tru[TRU_MATCH_COLS],  
        left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, TRU_SPEC_ID],  
        right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, TRU_SPEC_ID],  
        how='inner'  
    )  
    # Now match per description. Make sure to include only meaningful text  
    if not (reference_table['text_for_matching_erp'].isnull().all() or   
            reference_table['text_for_matching_tru'].isnull().all()):  
        reference_table_text = reference_table.dropna(subset=['text_for_matching_erp', 'text_for_matching_tru'])  
        is_valid_ref = [min(len(x), len(y)) > 5 for x, y in   
                        zip(reference_table_text['text_for_matching_erp'],   
                            reference_table_text['text_for_matching_tru'])]  
        reference_table_text = reference_table_text[is_valid_ref]  
        df_erp_with_additional_desc = erp[ERP_MATCH_COLS].merge(  
            reference_table_text[['text_for_matching_erp', 'text_for_matching_tru']].drop_duplicates(),  
            on='text_for_matching_erp',  
            how='inner'  
        )  
        matched_per_desc = df_erp_with_additional_desc.merge(  
            tru[TRU_MATCH_COLS],  
            left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, 'text_for_matching_tru'],  
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, 'text_for_matching_tru'],  
            how='inner'  
        )  
        matched_per_desc = matched_per_desc[matched_per_id.columns]  
    else:  
        matched_per_desc = pd.DataFrame(columns=matched_per_id.columns)
    #add by arvind
    if matched_per_id.empty and matched_per_desc.empty:
        print(f"No reference table matches found in round {match_round_name}")
        return pd.DataFrame(), erp, tru, last_match_round + 1  
    matches = pd.concat([matched_per_id, matched_per_desc], ignore_index=True)  
    matches[SCORE_COL] = 1  
    matches[UNIFIED_MC_COL] = matches[f'{ERP_MAT_NUM}_original'].copy()  
    matches['is_matched'] = True  
    matches['Matching Reason'] = round_name  
    matches['confidence'] = 'high'  
    matches = add_matches_bundles(matches, bundles, tru)  
    matches.drop_duplicates(subset=NON_DUPLICATES_SET, inplace=True)  
    assign_round_name_and_report_time(matches, match_round_name, start)  
    df_erp_to_match, df_tru_to_match = get_data_yet_to_match(matches, erp, tru)  
    # DEBUG BLOCK 1: Trace in Reference Table Matching
    debug_target_part_id = "668080"
    if not matches.empty and matches[ERP_PART_ID].eq(debug_target_part_id).any():
     print(f"\nâœ… [DEBUG] Found {debug_target_part_id} in Reference Table Matching ({round_name})")
     print(matches[matches[ERP_PART_ID] == debug_target_part_id][[
        ERP_PART_ID, TRU_SPEC_ID, 'Matching Reason', 'confidence']])

    return matches, df_erp_to_match, df_tru_to_match, last_match_round + 1  
    

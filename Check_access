# üü¢ Step 0: Filter out reference pairs missing Child Num
valid_pairs = forced_pairs[forced_pairs[TRU_SPEC_ID].notna()].copy()
skipped_count = len(forced_pairs) - len(valid_pairs)

if skipped_count > 0:
    print("=" * 60)
    print(f"‚ö†Ô∏è Skipping {skipped_count} reference pairs because TRU_SPEC_ID (Child Num) is missing in the reference table.")
    print("=" * 60)
    print("üîç Skipped reference pairs (first 5 shown):")
    print(forced_pairs[forced_pairs[TRU_SPEC_ID].isna()].head())
    print("=" * 60)

# üü¢ Step 1: Merge valid reference pairs with ERP and TRU
print(f"üîÑ Processing {len(valid_pairs)} reference pairs with non-null Child Num...")
forced_matches = erp_to_match[ERP_MATCH_COLS].merge(
    valid_pairs, on=ERP_PART_ID, how='inner'
).merge(
    tru_to_match[TRU_MATCH_COLS],
    left_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
    right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
    how='inner'
)

# üü¢ Step 2: Handle matches found in ERP/TRU
if not forced_matches.empty:
    print(f"‚úÖ Found {len(forced_matches)} reference pairs in ERP/TRU. Adding as forced matches.")
    print("üîç Example forced matches (first 5 shown):")
    print(forced_matches[[ERP_PART_ID, TRU_SPEC_ID]].head())
    forced_matches[SCORE_COL] = 1
    forced_matches[UNIFIED_MC_COL] = forced_matches[f'{ERP_MAT_NUM}_original'].copy()
    forced_matches['is_matched'] = True
    forced_matches['Matching Reason'] = round_name + ' (forced pair)'
    forced_matches['confidence'] = 'high'
    forced_matches['is_forced_match'] = True
    forced_matches = forced_matches[matches.columns]
else:
    print(f"‚ö†Ô∏è No ERP/TRU rows found for {len(valid_pairs)} reference pairs.")
    forced_matches = pd.DataFrame(columns=matches.columns)

# üü¢ Step 3: Handle valid reference pairs missing in ERP/TRU
missing_pairs = valid_pairs.merge(
    forced_matches[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
    on=[ERP_PART_ID, TRU_SPEC_ID],
    how='left',
    indicator=True
).query('_merge == "left_only"').drop(columns=['_merge'])

if not missing_pairs.empty:
    print(f"‚ö†Ô∏è {len(missing_pairs)} reference pairs not found in ERP/TRU. Marking as unmatched.")
    print("üîç Example unmatched pairs (first 5 shown):")
    print(missing_pairs.head())
    dummy_missing = missing_pairs.copy()
    dummy_missing[SCORE_COL] = 0
    dummy_missing['is_matched'] = False
    dummy_missing['Matching Reason'] = "Reference pair not found in ERP/TRU"
    dummy_missing['confidence'] = 'low'
    dummy_missing['is_forced_match'] = True
    # Fill in expected columns
    for col in matches.columns:
        if col not in dummy_missing.columns:
            dummy_missing[col] = None
    dummy_missing = dummy_missing[matches.columns]
else:
    dummy_missing = pd.DataFrame(columns=matches.columns)

# üü¢ Step 4: Combine real matches and unmatched pairs
forced_matches = pd.concat([forced_matches, dummy_missing], ignore_index=True)

# üü¢ Step 5: Append to main matches
matches = pd.concat([matches, forced_matches], ignore_index=True)
print(f"‚úÖ Total added to matches: {len(forced_matches)} (real: {len(forced_matches.query('is_matched==True'))}, unmatched: {len(forced_matches.query('is_matched==False'))})")

def match_by_reference_table(erp: pd.DataFrame,
                             tru: pd.DataFrame,
                             reference_table: pd.DataFrame,
                             last_match_round: int,
                             round_name: str,
                             bundles):
    '''
    A reference table contains two types of mappings, Part ID - RM Spec and their respective text descriptions.
    This method attempts to match records using the two types of mappings.
    '''
    match_round_name = f'{last_match_round + 1}: {round_name}'
    print(f'MATCH ROUND {match_round_name}')
    start = time.time()

    # üü¢ Step 1: Normal matching logic (unchanged)
    df_erp_with_additional_id = erp[ERP_MATCH_COLS].merge(
        reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
        on=ERP_PART_ID,
        how='inner'
    )

    matched_per_id = df_erp_with_additional_id.merge(
        tru[TRU_MATCH_COLS],
        left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, TRU_SPEC_ID],
        right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, TRU_SPEC_ID],
        how='inner'
    )

    # üü¢ Step 2: Match per description
    if not (reference_table['text_for_matching_erp'].isnull().all() or
            reference_table['text_for_matching_tru'].isnull().all()):
        reference_table_text = reference_table.dropna(subset=['text_for_matching_erp', 'text_for_matching_tru'])
        is_valid_ref = [min(len(x), len(y)) > 5 for x, y in
                        zip(reference_table_text['text_for_matching_erp'],
                            reference_table_text['text_for_matching_tru'])]
        reference_table_text = reference_table_text[is_valid_ref]
        df_erp_with_additional_desc = erp[ERP_MATCH_COLS].merge(
            reference_table_text[['text_for_matching_erp', 'text_for_matching_tru']].drop_duplicates(),
            on='text_for_matching_erp',
            how='inner'
        )
        matched_per_desc = df_erp_with_additional_desc.merge(
            tru[TRU_MATCH_COLS],
            left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, 'text_for_matching_tru'],
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, 'text_for_matching_tru'],
            how='inner'
        )
        matched_per_desc = matched_per_desc[matched_per_id.columns]
    else:
        matched_per_desc = pd.DataFrame(columns=matched_per_id.columns)

    if matched_per_id.empty and matched_per_desc.empty:
        print(f"No reference table matches found in round {match_round_name}")
        return pd.DataFrame(), erp, tru, last_match_round + 1

    matches = pd.concat([matched_per_id, matched_per_desc], ignore_index=True)
    matches[SCORE_COL] = 1
    matches[UNIFIED_MC_COL] = matches[f'{ERP_MAT_NUM}_original'].copy()
    matches['is_matched'] = True
    matches['Matching Reason'] = round_name
    matches['confidence'] = 'high'
    matches = add_matches_bundles(matches, bundles, tru)
    matches.drop_duplicates(subset=NON_DUPLICATES_SET, inplace=True)

    # üü¢ Step 3: Apply forced pairs logic for unmatched reference pairs
    print("-" * 60)
    print("üîÑ Checking for any unmatched reference pairs...")
    forced_pairs = reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates()

    unmatched_pairs = forced_pairs.merge(
        matches[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
        on=[ERP_PART_ID, TRU_SPEC_ID],
        how='left',
        indicator=True
    ).query('_merge == "left_only"').drop(columns=['_merge'])

    if unmatched_pairs.empty:
        print("‚úÖ All reference pairs were matched in previous logic.")
    else:
        print(f"‚ö†Ô∏è {len(unmatched_pairs)} reference pairs were NOT matched earlier. Applying forced pairs logic...")

        valid_pairs = unmatched_pairs[unmatched_pairs[TRU_SPEC_ID].notna()].copy()
        skipped_count = len(unmatched_pairs) - len(valid_pairs)

        if skipped_count > 0:
            print(f"‚ö†Ô∏è Skipping {skipped_count} reference pairs because TRU_SPEC_ID (Child Num) is missing in the reference table.")
            print("üîç Skipped reference pairs (first 5 shown):")
            print(unmatched_pairs[unmatched_pairs[TRU_SPEC_ID].isna()].head())

        forced_matches = erp[ERP_MATCH_COLS].merge(
            valid_pairs, on=ERP_PART_ID, how='inner'
        ).merge(
            tru[TRU_MATCH_COLS],
            left_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            how='inner'
        )

        if not forced_matches.empty:
            print(f"‚úÖ Found {len(forced_matches)} reference pairs in ERP/TRU. Adding as forced matches.")
            forced_matches[SCORE_COL] = 1
            forced_matches[UNIFIED_MC_COL] = forced_matches[f'{ERP_MAT_NUM}_original'].copy()
            forced_matches['is_matched'] = True
            forced_matches['Matching Reason'] = round_name + ' (forced pair)'
            forced_matches['confidence'] = 'high'
            if 'is_forced_match' in matches.columns:
                forced_matches['is_forced_match'] = True
            forced_matches = forced_matches[matches.columns]
        else:
            forced_matches = pd.DataFrame(columns=matches.columns)

        missing_pairs = valid_pairs.merge(
            forced_matches[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
            on=[ERP_PART_ID, TRU_SPEC_ID],
            how='left',
            indicator=True
        ).query('_merge == "left_only"').drop(columns=['_merge'])

        if not missing_pairs.empty:
            print(f"‚ö†Ô∏è {len(missing_pairs)} reference pairs not found in ERP/TRU. Marking as unmatched.")
            dummy_missing = missing_pairs.copy()
            dummy_missing[SCORE_COL] = 0
            dummy_missing['is_matched'] = False
            dummy_missing['Matching Reason'] = "Reference pair not found in ERP/TRU"
            dummy_missing['confidence'] = 'low'
            if 'is_forced_match' in matches.columns:
                dummy_missing['is_forced_match'] = True
            for col in matches.columns:
                if col not in dummy_missing.columns:
                    dummy_missing[col] = None
            dummy_missing = dummy_missing[matches.columns]
        else:
            dummy_missing = pd.DataFrame(columns=matches.columns)

        forced_matches = pd.concat([forced_matches, dummy_missing], ignore_index=True)
        matches = pd.concat([matches, forced_matches], ignore_index=True)
        print(f"‚úÖ Total forced pairs added: {len(forced_matches)} (real: {len(forced_matches.query('is_matched==True'))}, unmatched: {len(forced_matches.query('is_matched==False'))})")

    assign_round_name_and_report_time(matches, match_round_name, start)
    df_erp_to_match, df_tru_to_match = get_data_yet_to_match(matches, erp, tru)

    return matches, df_erp_to_match, df_tru_to_match, last_match_round + 1

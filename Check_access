import json
import logging
import os
import sys
import time
import uuid
import zipfile
import requests

# Your Azure Speech resource settings
SPEECH_ENDPOINT = "https://<your-resource-name>.cognitiveservices.azure.com/"
SUBSCRIPTION_KEY = "your-subscription-key"
API_VERSION = "2024-04-01"

# Sample input text
TEXT_INPUT = "Hello! This is a test of Azure's batch text to speech service. It will convert this paragraph into audio and generate timestamps for subtitles."

# Voice and language settings
VOICE = "en-US-JennyNeural"
LANG = "en-US"

# Output paths
SSML_FILE = "test_input.ssml"
OUTPUT_ZIP = "results.zip"
EXTRACT_DIR = "extracted_files"

def generate_ssml(text, voice=VOICE, lang=LANG):
    return f"""<speak version='1.0' xml:lang='{lang}'>
  <voice name='{voice}'>{text}</voice>
</speak>"""

def write_ssml_file(text, file_path=SSML_FILE):
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(generate_ssml(text))

def authenticate():
    return {'Ocp-Apim-Subscription-Key': SUBSCRIPTION_KEY}

def create_job_id():
    return str(uuid.uuid4())

def submit_synthesis(job_id, file_path=SSML_FILE):
    url = f'{SPEECH_ENDPOINT}/texttospeech/batchsyntheses/{job_id}?api-version={API_VERSION}'
    headers = {'Content-Type': 'application/json; charset=utf-8'}
    headers.update(authenticate())

    with open(file_path, "r", encoding="utf-8") as f:
        ssml_text = f.read()

    payload = {
        "inputKind": "SSML",
        "synthesisConfig": {
            "voice": VOICE
        },
        "inputs": [{"content": ssml_text}],
        "properties": {
            "outputFormat": "audio-24khz-160kbitrate-mono-mp3",
            "wordBoundaryEnabled": True,
            "sentenceBoundaryEnabled": True,
            "timeToLiveInHours": 168
        }
    }

    response = requests.put(url, json.dumps(payload), headers=headers)
    if response.status_code < 400:
        return job_id
    print(f"‚ùå Job submission failed: {response.status_code} - {response.text}")
    return None

def get_synthesis_status(job_id):
    url = f'{SPEECH_ENDPOINT}/texttospeech/batchsyntheses/{job_id}?api-version={API_VERSION}'
    return requests.get(url, headers=authenticate()).json()

def download_and_extract(url, output_path=OUTPUT_ZIP, extract_to=EXTRACT_DIR):
    r = requests.get(url)
    if r.status_code == 200:
        with open(output_path, "wb") as f:
            f.write(r.content)
        zipfile.ZipFile(output_path, "r").extractall(extract_to)
        print(f"‚úÖ Extracted to {extract_to}")
    else:
        print("‚ùå Failed to download output ZIP.")

def convert_to_srt_timestamp(seconds):
    millis = int((seconds - int(seconds)) * 1000)
    hours, remainder = divmod(int(seconds), 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:02}:{minutes:02}:{seconds:02},{millis:03}"

def process_srt_from_json(folder=EXTRACT_DIR):
    json_file = os.path.join(folder, "0001.sentence.json")
    if not os.path.exists(json_file):
        print("‚ùå sentence.json not found!")
        return
    with open(json_file, "r", encoding="utf-8") as f:
        data = json.load(f)

    srt_lines = []
    for i, sentence in enumerate(data, 1):
        start = sentence["AudioOffset"] / 1000
        end = start + sentence["Duration"] / 1000
        srt_lines.extend([
            str(i),
            f"{convert_to_srt_timestamp(start)} --> {convert_to_srt_timestamp(end)}",
            sentence["Text"],
            ""
        ])

    with open(os.path.join(folder, "output.srt"), "w", encoding="utf-8") as f:
        f.write("\n".join(srt_lines))
    print("‚úÖ SRT file created")

def run_batch_tts_pipeline():
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    write_ssml_file(TEXT_INPUT)
    job_id = create_job_id()

    print(f"üöÄ Submitting job {job_id}")
    if not submit_synthesis(job_id):
        return

    print("‚è≥ Waiting for synthesis to complete...")
    while True:
        result = get_synthesis_status(job_id)
        status = result.get("status")
        if status == "Succeeded":
            print("‚úÖ Synthesis succeeded!")
            result_url = result["outputs"]["result"]
            download_and_extract(result_url)
            process_srt_from_json()
            break
        elif status == "Failed":
            print(f"‚ùå Synthesis failed: {result}")
            break
        else:
            print(f"‚è≥ Still running... [{status}]")
            time.sleep(5)

# Run the full pipeline
run_batch_tts_pipeline()

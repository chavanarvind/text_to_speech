def match_by_reference_table(erp: pd.DataFrame,
                             tru: pd.DataFrame,
                             reference_table: pd.DataFrame,
                             last_match_round: int,
                             round_name: str,
                             bundles,
                             erp_full: pd.DataFrame,
                             tru_full: pd.DataFrame):
    """
    Match records using a reference table.
    For NLP_LIST_ERP, we process all pairs in force matching first,
    then run normal matching. Deduplication is applied at the end.
    """
    match_round_name = f'{last_match_round + 1}: {round_name}'
    print(f'üöÄ MATCH ROUND {match_round_name}')
    start = time.time()

    matches = pd.DataFrame()
    forced_matches = pd.DataFrame()

    # üü£ STEP 1: FORCE PAIR LOGIC FIRST for NLP_LIST_ERP
    if "nlp_list_erp" in round_name.lower():
        print("üîÑ Running FORCE PAIR matching for all pairs in NLP_LIST_ERP")

        forced_pairs = reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates()

        # Merge using erp_full and tru_full to ensure no pair is skipped
        forced_matches = erp_full[ERP_MATCH_COLS].merge(
            forced_pairs, on=ERP_PART_ID, how='inner'
        ).merge(
            tru_full[TRU_MATCH_COLS],
            left_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            how='inner'
        )

        if not forced_matches.empty:
            print(f"‚úÖ Found {len(forced_matches)} forced matches")
            forced_matches[SCORE_COL] = 1
            forced_matches[UNIFIED_MC_COL] = forced_matches[f'{ERP_MAT_NUM}_original'].copy()
            forced_matches['is_matched'] = True
            forced_matches['Matching Reason'] = round_name + " (forced pair)"
            forced_matches['confidence'] = 'high'
            forced_matches = add_matches_bundles(forced_matches, bundles, tru_full)
        else:
            print("‚ùå No forced matches found")

    # üü¢ STEP 2: NORMAL MATCHING (runs even if pairs matched in force)
    print("üîÑ Running NORMAL matching")
    df_erp_with_additional_id = erp[ERP_MATCH_COLS].merge(
        reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
        on=ERP_PART_ID,
        how='inner'
    )

    matched_per_id = df_erp_with_additional_id.merge(
        tru[TRU_MATCH_COLS],
        left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, TRU_SPEC_ID],
        right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, TRU_SPEC_ID],
        how='inner'
    )

    if not matched_per_id.empty:
        print(f"‚úÖ Found {len(matched_per_id)} normal matches")
        matched_per_id[SCORE_COL] = 1
        matched_per_id[UNIFIED_MC_COL] = matched_per_id[f'{ERP_MAT_NUM}_original'].copy()
        matched_per_id['is_matched'] = True
        matched_per_id['Matching Reason'] = round_name
        matched_per_id['confidence'] = 'high'
        matched_per_id = add_matches_bundles(matched_per_id, bundles, tru)
    else:
        print("‚ùå No normal matches found")

    # üü¢ Combine forced and normal matches
    matches = pd.concat([forced_matches, matched_per_id], ignore_index=True)

    # ‚úÖ Deduplicate
    nd = matches.duplicated(subset=NON_DUPLICATES_SET).sum()
    if nd > 0:
        print(f"‚ö†Ô∏è {nd} duplicates found during merge. Deduplicating...")
        matches.drop_duplicates(subset=NON_DUPLICATES_SET, inplace=True)

    assign_round_name_and_report_time(matches, match_round_name, start)

    df_erp_to_match, df_tru_to_match = get_data_yet_to_match(matches, erp, tru)
    return matches, df_erp_to_match, df_tru_to_match, last_match_round + 1

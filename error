def is_new_key_safe(key, lock, retries=3, delay=1):
    for attempt in range(retries):
        try:
            with lock:
                conn = sqlite3.connect(SQLITE_DB_PATH, timeout=5)  # Set a 5s timeout
                cursor = conn.cursor()
                cursor.execute(f"INSERT INTO {KEY_TABLE} (key) VALUES (?)", (key,))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            return False
        except sqlite3.OperationalError as e:
            if "database is locked" in str(e):
                print(f"[RETRY] DB locked for key {key}, retrying ({attempt + 1}/{retries})")
                time.sleep(delay)
            else:
                raise
        finally:
            try:
                conn.close()
            except:
                pass
    print(f"[SKIPPED] Gave up on key: {key}")
    return False

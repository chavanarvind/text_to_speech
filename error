def match_by_reference_table(
    erp_to_match: pd.DataFrame,
    tru_to_match: pd.DataFrame,
    reference_table: pd.DataFrame,
    last_match_round: int,
    round_name: str,
    bundles: pd.DataFrame,
    erp_full: pd.DataFrame,              # üÜï Full ERP for force pairs
    tru_full: pd.DataFrame               # üÜï Full TRU for force pairs
):
    """
    Match using a reference table with normal matching logic on filtered ERP/TRU
    and forced pair logic on full ERP/TRU.
    """
    match_round_name = f'{last_match_round + 1}: {round_name}'
    print(f"{'-'*60}\nMATCH ROUND: {match_round_name}")
    start = time.time()

    # üü¢ Debug: Check for target COMP ID and CHILD NUM in filtered ERP/TRU
    target_comp_id = "528926"
    target_child_num = "PC-0014319"

    if erp_to_match[ERP_PART_ID].astype(str).isin([target_comp_id]).any():
        print(f"‚úÖ COMP ID {target_comp_id} FOUND in filtered ERP (erp_to_match)")
    else:
        print(f"‚ùå COMP ID {target_comp_id} NOT FOUND in filtered ERP (erp_to_match)")

    if tru_to_match[TRU_SPEC_ID].astype(str).isin([target_child_num]).any():
        print(f"‚úÖ CHILD NUM {target_child_num} FOUND in filtered TRU (tru_to_match)")
    else:
        print(f"‚ùå CHILD NUM {target_child_num} NOT FOUND in filtered TRU (tru_to_match)")

    # üü¢ Step 1: Normal matching by Part ID
    df_erp_with_additional_id = erp_to_match[ERP_MATCH_COLS].merge(
        reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
        on=ERP_PART_ID,
        how='inner'
    )

    matched_per_id = df_erp_with_additional_id.merge(
        tru_to_match[TRU_MATCH_COLS],
        left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, TRU_SPEC_ID],
        right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, TRU_SPEC_ID],
        how='inner'
    )

    # üü¢ Step 2: Normal matching by Description
    reference_table_text = reference_table.dropna(subset=['text_for_matching_erp', 'text_for_matching_tru'])
    if not reference_table_text.empty:
        df_erp_with_additional_desc = erp_to_match[ERP_MATCH_COLS].merge(
            reference_table_text[['text_for_matching_erp', 'text_for_matching_tru']].drop_duplicates(),
            on='text_for_matching_erp',
            how='inner'
        )

        matched_per_desc = df_erp_with_additional_desc.merge(
            tru_to_match[TRU_MATCH_COLS],
            left_on=['SRC_SYS_CD', 'PLNT_CD', ERP_MAT_NUM, 'text_for_matching_tru'],
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_MAT_NUM, 'text_for_matching_tru'],
            how='inner'
        )
        matched_per_desc = matched_per_desc[matched_per_id.columns]
    else:
        matched_per_desc = pd.DataFrame(columns=matched_per_id.columns)

    # Combine normal matches
    matches = pd.concat([matched_per_id, matched_per_desc], ignore_index=True)

    if not matches.empty:
        matches[SCORE_COL] = 1
        matches[UNIFIED_MC_COL] = matches[f'{ERP_MAT_NUM}_original'].copy()
        matches['is_matched'] = True
        matches['Matching Reason'] = round_name
        matches['confidence'] = 'high'
        matches = add_matches_bundles(matches, bundles, tru_to_match)
        matches.drop_duplicates(subset=NON_DUPLICATES_SET, inplace=True)

    # üü¢ Step 3: Forced pair matching on full ERP/TRU
    print(f"{'-'*60}\nüîÑ FORCE PAIR LOGIC FOR UNMATCHED REFERENCE PAIRS")

    # üü¢ Debug: Check for target COMP ID and CHILD NUM in full ERP/TRU
    if erp_full[ERP_PART_ID].astype(str).isin([target_comp_id]).any():
        print(f"‚úÖ COMP ID {target_comp_id} FOUND in full ERP (erp_full)")
    else:
        print(f"‚ùå COMP ID {target_comp_id} NOT FOUND in full ERP (erp_full)")

    if tru_full[TRU_SPEC_ID].astype(str).isin([target_child_num]).any():
        print(f"‚úÖ CHILD NUM {target_child_num} FOUND in full TRU (tru_full)")
    else:
        print(f"‚ùå CHILD NUM {target_child_num} NOT FOUND in full TRU (tru_full)")

    forced_pairs = reference_table[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates()

    # Identify unmatched pairs
    unmatched_pairs = forced_pairs.merge(
        matches[[ERP_PART_ID, TRU_SPEC_ID]].drop_duplicates(),
        on=[ERP_PART_ID, TRU_SPEC_ID],
        how='left',
        indicator=True
    ).query('_merge == "left_only"').drop(columns=['_merge'])

    if not unmatched_pairs.empty:
        print(f"‚ö†Ô∏è {len(unmatched_pairs)} unmatched reference pairs. Applying force pair logic...")

        forced_matches = erp_full[ERP_MATCH_COLS].merge(
            unmatched_pairs, on=ERP_PART_ID, how='inner'
        ).merge(
            tru_full[TRU_MATCH_COLS],
            left_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            right_on=['SRC_SYS_CD', 'PLNT_CD', TRU_SPEC_ID],
            how='inner'
        )

        if not forced_matches.empty:
            print(f"‚úÖ Found {len(forced_matches)} force pair matches in full ERP/TRU")

            # üü¢ Debug: Check if target pair is matched
            pair_debug = forced_matches[
                (forced_matches[ERP_PART_ID] == target_comp_id) &
                (forced_matches[TRU_SPEC_ID] == target_child_num)
            ]
            if not pair_debug.empty:
                print(f"üéØ Target pair ({target_comp_id}, {target_child_num}) FOUND in forced matches!")
                print(pair_debug[[ERP_PART_ID, TRU_SPEC_ID, 'Matching Reason', 'confidence']])
            else:
                print(f"‚ùå Target pair ({target_comp_id}, {target_child_num}) NOT found in forced matches.")

            forced_matches[SCORE_COL] = 1
            forced_matches[UNIFIED_MC_COL] = forced_matches[f'{ERP_MAT_NUM}_original'].copy()
            forced_matches['is_matched'] = True
            forced_matches['Matching Reason'] = round_name + ' (forced pair)'
            forced_matches['confidence'] = 'high'
            forced_matches['is_forced_match'] = True

            forced_matches = add_matches_bundles(forced_matches, bundles, tru_full)

            # Add force matches to main matches
            matches = pd.concat([matches, forced_matches], ignore_index=True)
            matches.drop_duplicates(subset=NON_DUPLICATES_SET, inplace=True)
        else:
            print(f"‚ùå No force pair matches found in full ERP/TRU")

    else:
        print("‚úÖ All reference pairs matched during normal logic")

    assign_round_name_and_report_time(matches, match_round_name, start)

    # Update ERP/TRU to match for next rounds
    df_erp_to_match, df_tru_to_match = get_data_yet_to_match(matches, erp_to_match, tru_to_match)

    return matches, df_erp_to_match, df_tru_to_match, last_match_round + 1

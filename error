import os
import argparse
import pandas as pd
import numpy as np
import torch
import joblib
import gc
from datetime import datetime
from sentence_transformers import SentenceTransformer
from azureml.core import Run, Model

AI_OUTPUT_COLUMNS = [
    "CMPNT_MATL_NUM",
    "AI_FINAL_CATEGORY",
    "AI_FINAL_CATEGORY_CONFIDENCE",
    "AI_MATCHING_REASON_FINAL_CATEGORY",
    "AI_FINAL_SUBCATEGORY",
    "AI_FINAL_SUBCATEGORY_CONFIDENCE",
    "AI_MATCHING_REASON_FINAL_SUBCATEGORY"
]

def log(msg):
    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

def encode_descriptions(encoder, texts, batch_size=64):
    return encoder.encode(texts, batch_size=batch_size, show_progress_bar=True, convert_to_numpy=True)

def round_datetime_columns(df):
    for col in df.select_dtypes(include=["datetime64[ns]"]).columns:
        df[col] = df[col].dt.round("us")
    return df

def predict_category(df, encoder, model, scaler, ordinal):
    category_idx = df['needs_category_model'] == True
    df_cat = df[category_idx].copy()

    if df_cat.empty:
        return df

    descs = df_cat['CMPNT_MATL_DESC_CLEAN'].astype(str).tolist()
    embeddings = encode_descriptions(encoder, descs)

    X = np.hstack([
        embeddings,
        scaler.transform(df_cat[['CMPNT_MATL_DESC_LEN']]),
        ordinal.transform(df_cat[['UNIT_GROUP', 'CMPNT_MATL_TYPE_CATEGORY']])
    ])

    probs = model.predict_proba(X)
    preds = model.predict(X)
    scores = np.max(probs, axis=1)

    df.loc[category_idx, 'AI_FINAL_CATEGORY'] = np.where(scores < 0.6, 'Other', preds)
    df.loc[category_idx, 'AI_FINAL_CATEGORY_CONFIDENCE'] = scores
    df.loc[category_idx, 'AI_MATCHING_REASON_FINAL_CATEGORY'] = np.where(
        scores < 0.6, 'Low Confidence', 'lightgbm_Bert_RPM_Category_model'
    )
    return df

def predict_subcategory(df, encoder, subcategory_models):
    for cat, model_bundle in subcategory_models.items():
        subcat_idx = (df['AI_FINAL_CATEGORY'] == cat) & (df['needs_subcategory_model'] == True)
        df_sub = df[subcat_idx].copy()

        if df_sub.empty:
            continue

        descs = df_sub['CMPNT_MATL_DESC_CLEAN'].astype(str).tolist()
        embeddings = encode_descriptions(encoder, descs)

        X = np.hstack([
            embeddings,
            model_bundle['scaler'].transform(df_sub[['CMPNT_MATL_DESC_LEN']]),
            model_bundle['encoder'].transform(df_sub[['UNIT_GROUP', 'CMPNT_MATL_TYPE_CATEGORY']])
        ])

        probs = model_bundle['model'].predict_proba(X)
        preds = model_bundle['model'].predict(X)
        scores = np.max(probs, axis=1)

        df.loc[subcat_idx, 'AI_FINAL_SUBCATEGORY'] = np.where(scores < 0.6, 'Other', preds)
        df.loc[subcat_idx, 'AI_FINAL_SUBCATEGORY_CONFIDENCE'] = scores
        df.loc[subcat_idx, 'AI_MATCHING_REASON_FINAL_SUBCATEGORY'] = np.where(
            scores < 0.6, 'Low Confidence', f"RPM_Category_model_full_{cat}_V1"
        )
    return df

def apply_fallback(df):
    fallback_idx = (df['needs_subcategory_model'] == True) & (~df['AI_FINAL_CATEGORY'].isin(['CHM', 'PKG', 'FNW']))
    df.loc[fallback_idx, 'AI_FINAL_SUBCATEGORY'] = df.loc[fallback_idx, 'AI_FINAL_CATEGORY']
    df.loc[fallback_idx, 'AI_FINAL_SUBCATEGORY_CONFIDENCE'] = 0
    df.loc[fallback_idx, 'AI_MATCHING_REASON_FINAL_SUBCATEGORY'] = 'Fallback'
    return df

def main(input_path, final_output_dir):
    run = Run.get_context()
    ws = run.experiment.workspace

    log("ðŸ” Loading category model and encoders...")
    model_dir = Model.get_model_path("RPM_Category_model_full_cat", _workspace=ws)
    model = joblib.load(os.path.join(model_dir, "final_model.joblib"))
    ordinal = joblib.load(os.path.join(model_dir, "ordinal_encoder.pkl"))
    scaler = joblib.load(os.path.join(model_dir, "scaler.pkl"))

    encoder = SentenceTransformer(
        'pritamdeka/BioBERT-mnli-snli-scinli-scitail-mednli-stsb',
        device='cuda' if torch.cuda.is_available() else 'cpu'
    )
    encoder.max_seq_length = 128

    log("ðŸ“¦ Loading subcategory models...")
    subcategory_models = {}
    for cat in ['CHM', 'PKG', 'FNW']:
        model_path = Model.get_model_path(f"RPM_Category_model_full_{cat}_V1", _workspace=ws)
        subcategory_models[cat] = {
            "model": joblib.load(os.path.join(model_path, "final_model.joblib")),
            "encoder": joblib.load(os.path.join(model_path, "ordinal_encoder.pkl")),
            "scaler": joblib.load(os.path.join(model_path, "scaler.pkl")),
        }

    os.makedirs(final_output_dir, exist_ok=True)

    for fname in os.listdir(input_path):
        if not fname.endswith(".parquet"):
            continue

        try:
            log(f"ðŸ”Ž Predicting: {fname}")
            df = pd.read_parquet(os.path.join(input_path, fname))
            df = round_datetime_columns(df)

            df = predict_category(df, encoder, model, scaler, ordinal)
            df = predict_subcategory(df, encoder, subcategory_models)
            df = apply_fallback(df)

            df = df[df["CMPNT_MATL_NUM"].notnull()]
            df = df[AI_OUTPUT_COLUMNS]

            output_path = os.path.join(final_output_dir, fname)
            df.to_parquet(output_path, index=False)

            log(f"âœ… Saved: {output_path} ({len(df)} rows)")

        except Exception as e:
            log(f"âŒ Error on {fname}: {e}")
        finally:
            del df
            gc.collect()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--input_path", required=True)
    parser.add_argument("--final_output_dir", required=True)
    args = parser.parse_args()

    main(
        input_path=args.input_path,
        final_output_dir=args.final_output_dir
    )
